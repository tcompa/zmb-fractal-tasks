"""Segment spot-like particles."""

import json
from collections.abc import Sequence
from pathlib import Path
from typing import Optional

# import fractal_tasks_core
import numpy as np
from aicssegmentation.core.utils import hole_filling
from ngio import open_omezarr_container
from pydantic import validate_call
from scipy import ndimage
from skimage.feature import peak_local_max
from skimage.filters import gaussian
from skimage.segmentation import watershed

from zmb_fractal_tasks.normalization_utils import (
    CustomNormalizer,
    NormalizedChannelInputModel,
    normalized_image,
)

# __OME_NGFF_VERSION__ = fractal_tasks_core.__OME_NGFF_VERSION__


@validate_call
def segment_particles(
    *,
    # Fractal parameters
    zarr_url: str,
    # Core parameters
    level: str = "0",
    channel: NormalizedChannelInputModel,
    input_ROI_table: str = "FOV_ROI_table",
    output_ROI_table: Optional[str] = None,
    output_label_name: Optional[str] = None,
    # Segmentation parameters
    gaussian_smoothing_sigma: Optional[float] = None,
    s2_param: Sequence[Sequence[float]] = [
        [1, 0.04],
    ],
    fill_2d: bool = True,
    fill_max_size: float = 1000,
    # Overwrite option
    overwrite: bool = True,
) -> None:
    """Segment spot-like particles in 2D image.

    Function inspired by the Allen Cell & Structure Segmenter. The steps are:
    - Normalization (limits taken from OMERO-channel metadata)
    - Gaussian smoothing (gaussian_smoothing_sigma)
    - Laplacian of Gaussian filtering & thresholding at multiple scales (s2_param)
    - Hole filling (fill_2d, fill_max_size)
    - Seeded watershed segmentation, using the local maxima of the smoothed image
      (gaussian_smoothing_sigma) as seeds.

    Args:
        zarr_url: Path or url to the individual OME-Zarr image to be processed.
            (standard argument for Fractal tasks, managed by Fractal server).
        level: Pyramid level of the image to be segmented. Choose `0` to
            process at full resolution.
        channel: Channel for segmentation; requires either `wavelength_id`
            (e.g. `A01_C01`) or `label` (e.g. `DAPI`), but not both.
            Also contains normalization options:
            'default': Data is normalized so 0.0=1st percentile and 1.0=99th
            percentile of image intensities.
            'no_normalization': No normalization is applied.
            'custom': You can either provide your own rescaling percentiles or
            fixed rescaling upper and lower bound integers.
            'omero': The "start" and "end" values from the omero channels in
            the zarr file are used for upper and lower bounds.
        input_ROI_table: Name of the ROI table over which the task loops to
            apply segmentation. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_ROI_table: If provided, a ROI table with that name is created,
            which will contain the bounding boxes of the newly segmented
            labels. ROI tables should have `ROI` in their name.
        output_label_name: Name of the output label image (e.g. `"organoids"`).
        gaussian_smoothing_sigma: sigma for preprocessing gaussian filter
            (in pixels @ level0)
        s2_param: list of list of parameters for segmentation.
            The first element is the sigma for the laplacian of gaussian, and the
            second element is the threshold for the filtered image:
            [[sigma1, threshold1], [sigma2, threshold2], ...]
            e.g. [[1, 0.04], [1.5, 0.8], [2, 0.15], [4, 0.20]]
            (sigma in pixels @ chosen level)
        fill_2d: If True, holes will be filled
        fill_max_size: maximum hole-size to be filled (in pixels @ level0)
        overwrite: If `True`, overwrite the task output.
    """
    omezarr = open_omezarr_container(zarr_url)
    image = omezarr.get_image(path=level)

    roi_table = omezarr.get_table(input_ROI_table, check_type="roi_table")

    omero_channel = channel.get_omero_channel(zarr_url)
    channel_idx = image.channel_labels.index(omero_channel.label)

    if channel.normalize.mode == "omero":
        # load normalization from omero channel
        channel.update_normalization_from_omero(zarr_url)

    if output_label_name is None:
        output_label_name = "particles"

    label_image = omezarr.derive_label(
        name=output_label_name, overwrite=overwrite, ref_image=image, dtype="uint32"
    )

    max_label = 0
    for roi in roi_table.rois():
        patch = image.get_roi(roi, c=channel_idx)
        segmentation = segment_ROI(
            patch,
            gaussian_smoothing_sigma=gaussian_smoothing_sigma,
            s2_param=s2_param,
            fill_2d=fill_2d,
            fill_max_size=fill_max_size,
            normalize=channel.normalize,
        )
        # Add the max label of the previous segmentation to avoid overlapping labels
        binary = segmentation > 0
        segmentation[binary] += max_label
        max_label = segmentation.max()

        segmentation = segmentation[0]  # drop channel axis TODO: ask if necessary

        label_image.set_roi(patch=segmentation, roi=roi)

    # Consolidate the segmentation image
    label_image.consolidate()

    # TODO: Add ROI table with bounding boxes of the labels

    # TODO: fix label .zattrs (wait for ngio update)
    # QUICK FIX: Manually adjust the label image .zattrs
    with open(Path(zarr_url) / "labels" / output_label_name / ".zattrs", "r+") as f:
        json_data = json.load(f)
        json_data["image-label"] = json_data.pop("image_label")
        json_data["name"] = output_label_name
        f.seek(0)
        json.dump(json_data, f, indent=4)
        f.truncate()


def gaussian_laplace_threshold(
    struct_img: np.ndarray,
    s2_param: Sequence[Sequence[float]],
):
    """Spot-segmentation via laplacian of gaussian.

    Args:
        struct_img: image to be segmented.
        s2_param: list of list of parameters for segmentation.
            The first element is the sigma for the laplacian of gaussian, and the
            second element is the threshold for the filtered image:
            [[sigma1, threshold1], [sigma2, threshold2], ...]
            e.g. [[1, 0.04], [1.5, 0.8], [2, 0.15], [4, 0.20]]
    """
    bw = np.zeros(struct_img.shape, dtype=bool)
    for fid in range(len(s2_param)):
        log_sigma = s2_param[fid][0]
        response = -1 * (log_sigma**2) * ndimage.gaussian_laplace(struct_img, log_sigma)
        bw = np.logical_or(bw, response > s2_param[fid][1])
    return bw


def spot_mask_2D(
    x: np.ndarray,
    gaussian_smoothing_sigma: float,
    s2_param: Sequence[Sequence[float]],
    fill_2d: bool = True,
    fill_max_size: float = 1000,
):
    """Spot-segmentation via laplacian of gaussian.

    Args:
        x: 2D image to be segmented
        gaussian_smoothing_sigma: sigma for preprocessing gaussian filter
        s2_param: list of list of parameters for segmentation.
            The first element is the sigma for the laplacian of gaussian, and the
            second element is the threshold for the filtered image:
            [[sigma1, threshold1], [sigma2, threshold2], ...]
            e.g. [[1, 0.04], [1.5, 0.8], [2, 0.15], [4, 0.20]]
        fill_2d: If True, holes will be filled
        fill_max_size: maximum hole-size to be filled

        normalize: By default, data is normalized so 0.0=1st percentile and
            1.0=99th percentile of image intensities in each channel.
            You can turn off the default rescaling. With the "custom" option,
            you can either provide your own rescaling percentiles or fixed
            rescaling upper and lower bound integers.
    """
    if gaussian_smoothing_sigma:
        x = gaussian(x, sigma=gaussian_smoothing_sigma, preserve_range=True)
    mask = gaussian_laplace_threshold(x, s2_param)
    mask = hole_filling(mask, 0, fill_max_size, fill_2d)
    return mask


def separate_watershed(img, mask, sigma):
    """Perform instance segmentation of a mask via watershed.

    1. Gaussian filter image with sigma
    2. Find local intensity maxima (inside mask)
    3. Perform seeded watershed along intensity of image, with maximas as
       seed-points, inside of mask
    """
    # TODO: There are inconsistencies with the watershed algorithm, if there is
    # anisotropy in xy and z
    img_processed = gaussian(img, sigma=sigma)
    coords = peak_local_max(
        img_processed, labels=mask, min_distance=sigma, exclude_border=False
    )
    maximas = np.zeros(img.shape, dtype=bool)
    maximas[tuple(coords.T)] = True
    maximas, _ = ndimage.label(maximas)
    labels = watershed(-img_processed, maximas, mask=mask)
    return labels


def segment_ROI(
    img: np.ndarray,
    gaussian_smoothing_sigma: float,
    s2_param: Sequence[Sequence[float]],
    fill_2d: bool = True,
    fill_max_size: float = 1000,
    normalize: CustomNormalizer = None,
):
    """Instance spot-segmentation via laplacian of gaussian and intensity-watershed

    Args:
        img: 4D numpy array. czyx-image to be segmented. c-dimension should
            only have size 1.
        gaussian_smoothing_sigma: sigma for preprocessing gaussian filter
        s2_param: list of list of parameters for segmentation.
            The first element is the sigma for the laplacian of gaussian, and the
            second element is the threshold for the filtered image:
            [[sigma1, threshold1], [sigma2, threshold2], ...]
            e.g. [[1, 0.04], [1.5, 0.8], [2, 0.15], [4, 0.20]]
        fill_2d: If True, holes will be filled
        fill_max_size: maximum hole-size to be filled
        normalize: By default, data is normalized so 0.0=1st percentile and
            1.0=99th percentile of image intensities in each channel.
            You can turn off the default rescaling. With the "custom" option,
            you can either provide your own rescaling percentiles or fixed
            rescaling upper and lower bound integers.
    """
    if normalize is None:
        normalize = CustomNormalizer()
    if normalize.mode == "default":
        img = normalized_image(img, lower_p=1.0, upper_p=99.0)
    elif normalize.mode == "omero":
        raise ValueError(
            "Normalization mode 'omero' not supported for this function.\n"
            "Hint: First run:\n"
            "NormalizedChannelInputModel.update_normalization_from_omero(zarr_url)"
        )
    elif normalize.mode == "custom":
        img = normalized_image(
            img,
            lower_p=normalize.lower_percentile,
            upper_p=normalize.upper_percentile,
            lower_bound=normalize.lower_bound,
            upper_bound=normalize.upper_bound,
        )

    if img.shape[0] != 1:
        raise ValueError("Input image should have only one channel")
    img_zyx = img[0]

    mask = np.empty_like(img_zyx, dtype="bool")
    for z in range(img_zyx.shape[0]):
        mask[z] = spot_mask_2D(
            img_zyx[z],
            gaussian_smoothing_sigma,
            s2_param,
            fill_2d,
            fill_max_size,
        )
    labels = separate_watershed(img_zyx, mask, 1)
    return np.reshape(labels, img.shape)


# if __name__ == "__main__":
#     from fractal_tasks_core.tasks._utils import run_fractal_task

#     run_fractal_task(task_function=segment_particles)
