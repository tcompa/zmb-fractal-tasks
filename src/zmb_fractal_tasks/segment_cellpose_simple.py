"""Fractal task to segment single channel with cellpose."""

from collections.abc import Sequence
from typing import Optional

import numpy as np
from cellpose import models
from ngio import open_ome_zarr_container
from pydantic import validate_call

from zmb_fractal_tasks.utils.normalization import (
    CustomNormalizer,
    NormalizedChannelInputModel,
    normalized_image,
)


@validate_call
def segment_cellpose_simple(
    *,
    # Fractal parameters
    zarr_url: str,
    # Core parameters
    level: str = "0",
    channel: NormalizedChannelInputModel,
    input_ROI_table: str = "FOV_ROI_table",
    output_ROI_table: Optional[str] = None,
    output_label_name: Optional[str] = None,
    # Segmentation parameters
    gpu: bool = False,
    model_type: str = "nuclei",
    batch_size: int = 8,
    diameter: float = 30.0,
    resample: bool = False,
    # Overwrite option
    overwrite: bool = True,
) -> None:
    """Segment a single channel using cellpose.

    Args:
        zarr_url: Path or url to the individual OME-Zarr image to be processed.
            (standard argument for Fractal tasks, managed by Fractal server).
        level: Pyramid level of the image to be segmented. Choose `0` to
            process at full resolution.
        channel: Channel for segmentation; requires either `wavelength_id`
            (e.g. `A01_C01`) or `label` (e.g. `DAPI`), but not both.
            Also contains normalization options:
            'default': Data is normalized so 0.0=1st percentile and 1.0=99th
            percentile of image intensities.
            'no_normalization': No normalization is applied.
            'custom': You can either provide your own rescaling percentiles or
            fixed rescaling upper and lower bound integers.
            'omero': The "start" and "end" values from the omero channels in
            the zarr file are used for upper and lower bounds.
            'histogram': A precalculated histogram is used for normalization.
            Percentiles need to be provided.
        input_ROI_table: Name of the ROI table over which the task loops to
            apply segmentation. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_ROI_table: If provided, a ROI table with that name is created,
            which will contain the bounding boxes of the newly segmented
            labels. ROI tables should have `ROI` in their name.
        output_label_name: Name of the output label image (e.g. `"organoids"`).
        gpu: If `True`, use the GPU for segmentation.
        model_type: Type of cellpose model to use for segmentation.
        batch_size: Batch size for cellpose.
        diameter: Diameter of the objects to be segmented (pixels at level 0).
        resample: Run dynamics at original image size (will be slower but
            create more accurate boundaries).
        overwrite: If `True`, overwrite the task output.
    """
    omezarr = open_ome_zarr_container(zarr_url)
    image = omezarr.get_image(path=level)

    if image.is_3d:
        raise ValueError("Only 2D images are supported")
    if image.is_time_series:
        raise ValueError("Time series are not supported")

    roi_table = omezarr.get_table(input_ROI_table, check_type="roi_table")

    omero_channel = channel.get_omero_channel(zarr_url)
    channel_idx = image.channel_labels.index(omero_channel.label)

    downsample_factor = image.pixel_size.x / omezarr.get_image().pixel_size.x
    diameter_downsampled = diameter / downsample_factor

    if channel.normalize.mode == "omero":
        # load normalization from omero channel
        channel.update_normalization_from_omero(zarr_url)
    if channel.normalize.mode == "histogram":
        # load normalization from histogram
        channel.update_normalization_from_histogram(zarr_url)

    if output_label_name is None:
        output_label_name = "cellpose"

    omezarr.derive_label(name=output_label_name, overwrite=overwrite)
    label_image = omezarr.get_label(name=output_label_name, path=level)

    # load data
    cellpose_patches = []
    for roi in roi_table.rois():
        patch = image.get_roi(roi, c=channel_idx, axes_order="czyx")
        cellpose_patches.append(patch[channel_idx, 0])
    # compute segmetnations
    masks = segment_ROIs(
        images=cellpose_patches,
        gpu=gpu,
        model_type=model_type,
        batch_size=batch_size,
        diameter=diameter_downsampled,
        resample=resample,
        normalize=channel.normalize,
    )
    # save segmentations
    max_label = 0
    for roi, mask in zip(roi_table.rois(), masks):
        if mask.max() > 0:
            binary = mask > 0
            mask[binary] += max_label
            max_label = mask.max()
        label_image.set_roi(patch=mask[None, None, ...], roi=roi, axes_order="czyx")

    # Consolidate the segmentation image
    label_image.consolidate()

    # TODO: Add ROI table with bounding boxes of the labels
    if output_ROI_table is not None:
        raise NotImplementedError("ROI table output not implemented yet")


def segment_ROIs(
    images: Sequence[np.ndarray],
    gpu: bool,
    model_type: str,
    batch_size: int,
    diameter: float,
    resample: bool,
    normalize: CustomNormalizer,
) -> Sequence[np.ndarray]:
    """Segment 2D ROIs using Cellpose."""
    if normalize is None:
        normalize = CustomNormalizer()
    if normalize.mode == "omero":
        raise ValueError(
            "Normalization mode 'omero' not supported for this function.\n"
            "Hint: First run:\n"
            "NormalizedChannelInputModel.update_normalization_from_omero(zarr_url)"
        )
    elif normalize.mode == "custom":
        images = [
            normalized_image(
                img,
                lower_p=normalize.lower_percentile,
                upper_p=normalize.upper_percentile,
                lower_bound=normalize.lower_bound,
                upper_bound=normalize.upper_bound,
            )
            for img in images
        ]
    model = models.Cellpose(gpu=gpu, model_type=model_type)
    masks, *_ = model.eval(
        images,
        diameter=diameter,
        channels=[[0, 0]],
        batch_size=batch_size,
        resample=resample,
        normalize=normalize.use_default_normalization,
    )
    return masks


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(task_function=segment_cellpose_simple)
